<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scribble Party</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap');
        
        body {
            font-family: 'Outfit', sans-serif;
            background-color: #f8fafc;
            touch-action: none;
        }

        .canvas-container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05);
            background: white;
            border-radius: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        #drawing-canvas {
            cursor: crosshair;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        .message {
            animation: slideIn 0.2s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .scrollbar-hide::-webkit-scrollbar { display: none; }

        /* Kick Button Styles */
        .kick-btn {
            min-width: 50px;
            font-weight: 600;
        }
        
        .kick-btn:hover {
            transform: scale(1.05);
        }
        
        .kick-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="min-h-screen p-4 flex flex-col items-center">

    <!-- Auth / Join Overlay -->
    <div id="join-overlay" class="fixed inset-0 bg-indigo-600/90 z-[100] flex items-center justify-center p-6 transition-all">
        <div class="bg-white p-8 rounded-3xl shadow-2xl w-full max-w-md text-center">
            <h1 class="text-4xl font-800 text-indigo-600 mb-2">SCRIBBLE<span class="text-pink-500">PARTY</span></h1>
            <p class="text-slate-500 mb-8">Multiplayer drawing fun!</p>
            
            <div class="space-y-4">
                <input type="text" id="player-name" placeholder="Your Name" class="w-full p-4 bg-slate-100 rounded-2xl border-none outline-none focus:ring-2 focus:ring-indigo-400 font-semibold">
                <input type="text" id="room-id" placeholder="Room ID (e.g. FUN-123)" class="w-full p-4 bg-slate-100 rounded-2xl border-none outline-none focus:ring-2 focus:ring-indigo-400 font-semibold uppercase">
                <button id="join-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white p-4 rounded-2xl font-bold text-lg shadow-lg transition-all active:scale-95">
                    Enter Party
                </button>
            </div>
            <p id="auth-status" class="mt-4 text-xs text-slate-400">Connecting to server...</p>
        </div>
    </div>

    <!-- Reconnection Modal -->
    <div id="reconnect-modal" class="fixed inset-0 bg-black/70 z-[200] hidden items-center justify-center p-6">
        <div class="bg-white p-8 rounded-3xl shadow-2xl w-full max-w-md text-center">
            <h2 class="text-2xl font-bold text-indigo-600 mb-4">Reconnect to Game</h2>
            <p class="text-slate-600 mb-6">It looks like you were disconnected from the game. Would you like to reconnect?</p>
            <div class="space-y-3">
                <button id="reconnect-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white p-4 rounded-2xl font-bold text-lg transition-all shadow-lg active:scale-95">
                    Reconnect
                </button>
                <button id="new-game-btn" class="w-full bg-gray-100 hover:bg-gray-200 text-gray-800 p-4 rounded-2xl font-bold text-lg transition-all active:scale-95">
                    Start New Game
                </button>
            </div>
        </div>
    </div>

    <!-- Main Game UI -->
    <div id="game-ui" class="w-full max-w-6xl hidden">
        <header class="flex flex-wrap justify-between items-center mb-6 gap-4">
            <div>
                <h1 class="text-3xl font-800 text-indigo-600 tracking-tight">SCRIBBLE<span class="text-pink-500">PARTY</span></h1>
                <div class="flex items-center gap-3">
                    <p id="room-display" class="text-slate-400 text-sm font-bold uppercase tracking-widest"></p>
                    <button id="end-room-btn" class="hidden bg-red-500 hover:bg-red-600 text-white text-xs font-bold px-3 py-1.5 rounded-lg transition-colors">
                        End Party
                    </button>
                </div>
            </div>
            
            <div class="flex items-center gap-4 bg-white p-3 rounded-2xl shadow-sm border border-slate-200">
                <div class="text-center px-4">
                    <p class="text-xs font-semibold text-slate-400 uppercase">Time Left</p>
                    <p id="timer-display" class="text-2xl font-bold text-slate-800">60s</p>
                </div>
                <div class="h-10 w-[1px] bg-slate-200"></div>
                <div id="target-container" class="px-4 hidden">
                    <p class="text-xs font-semibold text-slate-400 uppercase">Your Word</p>
                    <p id="target-word" class="text-2xl font-bold text-pink-500">CAT</p>
                </div>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            <!-- Player List -->
            <div class="lg:col-span-2 space-y-4">
                <div class="bg-white p-4 rounded-3xl shadow-sm border border-slate-200">
                    <h3 class="font-bold text-slate-400 text-xs uppercase tracking-widest mb-4">Players</h3>
                    <div id="player-list" class="space-y-3 max-h-[400px] overflow-y-auto scrollbar-hide"></div>
                </div>
                <div id="drawer-tools" class="bg-white p-4 rounded-3xl shadow-sm border border-slate-200 hidden">
                    <h3 class="font-bold text-slate-400 text-xs uppercase tracking-widest mb-4">Tools</h3>
                    <div class="grid grid-cols-5 gap-2 mb-4">
                        <button onclick="setColor('#000000')" class="w-full aspect-square rounded-lg bg-black border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Black"></button>
                        <button onclick="setColor('#ef4444')" class="w-full aspect-square rounded-lg bg-red-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Red"></button>
                        <button onclick="setColor('#3b82f6')" class="w-full aspect-square rounded-lg bg-blue-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Blue"></button>
                        <button onclick="setColor('#22c55e')" class="w-full aspect-square rounded-lg bg-green-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Green"></button>
                        <button onclick="setColor('#eab308')" class="w-full aspect-square rounded-lg bg-yellow-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Yellow"></button>
                        
                        <button onclick="setColor('#a855f7')" class="w-full aspect-square rounded-lg bg-purple-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Purple"></button>
                        <button onclick="setColor('#f97316')" class="w-full aspect-square rounded-lg bg-orange-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Orange"></button>
                        <button onclick="setColor('#ec4899')" class="w-full aspect-square rounded-lg bg-pink-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Pink"></button>
                        <button onclick="setColor('#854d0e')" class="w-full aspect-square rounded-lg bg-[#854d0e] border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Brown"></button>
                        <button onclick="setColor('#64748b')" class="w-full aspect-square rounded-lg bg-slate-500 border-2 border-white shadow-sm hover:scale-110 transition-transform" title="Gray"></button>
                    </div>
                    <div class="space-y-2">
                        <button id="clear-btn" class="w-full py-2 bg-pink-50 text-pink-600 rounded-xl font-bold text-sm hover:bg-pink-100 transition-colors">Clear Canvas</button>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="change-word-btn" class="w-full py-2 bg-indigo-50 text-indigo-600 rounded-xl font-bold text-sm hover:bg-indigo-100 transition-colors">New Word</button>
                            <button id="skip-round-btn" class="w-full py-2 bg-orange-50 text-orange-600 rounded-xl font-bold text-sm hover:bg-orange-100 transition-colors">End Round</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Drawing Area -->
            <div class="lg:col-span-7 flex flex-col gap-4">
                <div class="canvas-container aspect-video border border-slate-200">
                    <canvas id="drawing-canvas"></canvas>
                </div>
            </div>

            <!-- Guess Area -->
            <div class="lg:col-span-3 flex flex-col">
                <div class="bg-white rounded-3xl shadow-sm border border-slate-200 flex flex-col h-[500px]">
                    <div class="p-4 border-b border-slate-100">
                        <h3 class="font-bold text-slate-700">Guesses</h3>
                    </div>
                    <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-2 scrollbar-hide"></div>
                    <div class="p-4 bg-slate-50 rounded-b-3xl">
                        <form id="chat-form" class="relative">
                            <input type="text" id="chat-input" placeholder="Type your guess..." class="w-full p-3 pr-12 bg-white rounded-xl border border-slate-200 outline-none">
                            <button type="submit" class="absolute right-2 top-1/2 -translate-y-1/2 text-indigo-500">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, collection, addDoc, getDoc, getDocs, writeBatch, deleteDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Environment adaptation for previewer
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDLfz0fUXanGv-pzpB5h-_QPMqZ4RBLaYI",
            authDomain: "scribble-11be3.firebaseapp.com",
            projectId: "scribble-11be3",
            storageBucket: "scribble-11be3.firebasestorage.app",
            messagingSenderId: "806428230012",
            appId: "1:806428230012:web:e74bc2fd33b84646dc24f9",
            measurementId: "G-Y2XBQPJPQ0"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Environment adaptation for previewer
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'scribble-party-v14'; 

        const WORDS = ["Apple", "Ball", "Cat", "Dog", "Egg", "Fish", "Ghost", "Hat", "Ice", "Joker", "Kite", "Lion", "Moon", "Nose", "Owl", "Pizza", "Queen", "Robot", "Sun", "Tree", "Umbrella", "Violin", "Watch", "Xylophone", "Yacht", "Zebra", "Airplane", "Boat", "Car", "Drum", "Ear", "Flower", "Grape", "House", "Igloo", "Jug", "Key", "Lamp", "Mouse", "Net", "Orange", "Pencil", "Quilt", "Rainbow", "Snake", "Train", "Unicorn", "Vase", "Whale", "Box", "Anchor", "Balloon", "Cactus", "Diamond", "Eye", "Feather", "Guitar", "Hammer", "Island", "Jellyfish", "Kangaroo", "Ladder", "Magnet", "Needle", "Octopus", "Parrot", "Rocket", "Spider", "Turtle", "Volcano", "Window", "Yoyo", "Zipper", "Ant", "Bed", "Camera", "Door", "Envelope", "Fire", "Glasses", "Heart", "Iron", "Jeans", "Knife", "Leaf", "Mushroom", "Necklace", "Onion", "Pillow", "Ring", "Scissors", "Tent", "Sock", "Spoon", "Wheel", "Bread", "Cheese", "Duck", "Frog", "Star", "Anchor", "Apron", "Badge", "Bag", "Bamboo", "Bandage", "Barn", "Barrel", "Bead", "Beard", "Beetle", "Bikini", "Biscuit", "Blade", "Blanket", "Blender", "Blimp", "Boots", "Bracelet", "Brain", "Branch", "Bread", "Brick", "Broccoli", "Bubble", "Buffet", "Bullet", "Bumper", "Button", "Cabin", "Cable", "Cage", "Calc", "Cannon", "Canoe", "Cape", "Carrot", "Cart", "Cave", "Cell", "Chain", "Chalk", "Cheek", "Chest", "Chin", "Chip", "Chisel", "Cigar", "Clamp", "Claw", "Cliff", "Cloak", "Clock", "Cloth", "Cloud", "Clover", "Club", "Coach", "Coal", "Coast", "Cockroach", "Coffee", "Coffin", "Collar", "Comet", "Compass", "Computer", "Cone", "Cork", "Corn", "Corner", "Couch", "Crane", "Crate", "Crayon", "Cream", "Creek", "Cricket", "Crow", "Crowbar", "Crust", "Crutch", "Crystal", "Cube", "Cuff", "Cupcake", "Curtain", "Curve", "Cushion", "Cyclops", "Cylinder", "Daisy", "Dart", "Deck", "Deer", "Dentist", "Desert", "Desk", "Dial", "Diaper", "Angel", "Arrow", "Axe", "Banana", "Basket", "Bat", "Bear", "Bee", "Bell", "Belt", "Bench", "Bike", "Bird", "Bone", "Book", "Boot", "Bottle", "Bowl", "Brain", "Brick", "Bridge", "Broom", "Brush", "Bucket", "Bug", "Bulb", "Bunny", "Burger", "Bus", "Cake", "Camel", "Candle", "Candy", "Castle", "Chain", "Chair", "Chalk", "Cherry", "Chess", "Chicken", "Circle", "Clock", "Cloud", "Clown", "Coat", "Coin", "Comb", "Cookie", "Corn", "Cow", "Crab", "Cross", "Crown", "Cup", "Desk", "Dice", "Dinosaur", "Doll", "Dolphin", "Donut", "Dress", "Drill", "Eagle", "Earth", "Fence", "Finger", "Flag", "Fly", "Foot", "Fork", "Fox", "Fries", "Gate", "Gear", "Giraffe", "Glove", "Goat", "Gold", "Grass", "Hair", "Hand", "Helmet", "Hook", "Horn", "Horse", "Hose", "Jar", "Jeep", "Knee", "Knot", "Ladder", "Lemon", "Lock", "Log", "Map", "Mask", "Maze", "Milk", "Mirror", "Monkey", "Mouth", "Mug", "Nail"]

        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const playerListEl = document.getElementById('player-list');
        const chatMessagesEl = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const joinOverlay = document.getElementById('join-overlay');
        const reconnectModal = document.getElementById('reconnect-modal');
        const gameUI = document.getElementById('game-ui');
        const timerDisplay = document.getElementById('timer-display');
        const targetContainer = document.getElementById('target-container');
        const targetWordText = document.getElementById('target-word');
        const drawerTools = document.getElementById('drawer-tools');
        const endRoomBtn = document.getElementById('end-room-btn');
        
        let currentUser = null;
        let currentRoom = null;
        let currentRole = 'guesser'; 
        let currentDrawerId = null; 
        let currentWord = "";
        let isDrawing = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let lastX = 0;
        let lastY = 0;
        let strokeBuffer = [];
        let bufferTimer = null;
        let myPlayerKey = null;
        let hostTimerInterval = null;
        let correctGuessers = []; 
        let isFlushing = false;
        let roundDrawingStarted = false; 
        let currentHostUid = null;

        // Presence variables
        let presenceInterval = null;
        let lastActiveUpdate = 0;
        const ACTIVITY_THRESHOLD = 5000; // 5 seconds
        const INACTIVE_THRESHOLD = 30000; // 30 seconds for host to clean up

        // Environment auth adaptation
        const initAuth = async () => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };
        initAuth();

        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (user) {
                document.getElementById('auth-status').textContent = "Ready!";
                
                // Reconnection check
                const lastRoom = localStorage.getItem('scribble_last_room');
                const lastPlayerName = localStorage.getItem('scribble_player_name');
                if (lastRoom && lastPlayerName && !currentRoom) {
                    reconnectModal.classList.remove('hidden');
                    reconnectModal.classList.add('flex');
                    document.getElementById('reconnect-btn').onclick = () => {
                         document.getElementById('player-name').value = lastPlayerName;
                         document.getElementById('room-id').value = lastRoom;
                         document.getElementById('join-btn').click();
                         reconnectModal.classList.add('hidden');
                    };
                    document.getElementById('new-game-btn').onclick = () => {
                        localStorage.removeItem('scribble_last_room');
                        reconnectModal.classList.add('hidden');
                    };
                }
            }
        });

        document.getElementById('join-btn').onclick = async () => {
            if (!currentUser) return;
            const name = document.getElementById('player-name').value.trim();
            const room = document.getElementById('room-id').value.trim().toUpperCase();
            if (!name || !room) return;

            // Save for reconnection
            localStorage.setItem('scribble_last_room', room);
            localStorage.setItem('scribble_player_name', name);

            currentRoom = room;
            joinOverlay.classList.add('hidden');
            gameUI.classList.remove('hidden');
            document.getElementById('room-display').textContent = `Room: ${room}`;

            // Consistent Player Key (Fix for duplicate players on reload)
            myPlayerKey = `${currentUser.uid}_${room}`;

            const existingPlayerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + room, myPlayerKey);
            const existingPlayerSnap = await getDoc(existingPlayerRef);

            if (existingPlayerSnap.exists()) {
                // Player reconnecting - update status
                await updateDoc(existingPlayerRef, {
                    name: name,
                    lastActive: Date.now(),
                    online: true
                });
                // Ensure score field exists
                if (existingPlayerSnap.data().score === undefined) {
                    await updateDoc(existingPlayerRef, { score: 0 });
                }
            } else {
                // New player
                await setDoc(existingPlayerRef, {
                    name,
                    score: 0,
                    id: myPlayerKey,
                    uid: currentUser.uid,
                    lastActive: Date.now(),
                    online: true,
                    room: room
                });
            }

            // Room Setup
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', room);
            const roomSnap = await getDoc(roomRef);
            
            if (!roomSnap.exists()) {
                await setDoc(roomRef, {
                    hostUid: currentUser.uid, 
                    drawerId: myPlayerKey,
                    currentWord: WORDS[Math.floor(Math.random() * WORDS.length)],
                    timer: 60,
                    correctGuessers: [],
                    drawingStarted: false 
                });
            }

            listenToRoom(myPlayerKey);
            startPresenceUpdates(); // Start heartbeat
            resizeCanvas();
        };

        // --- PRESENCE & CLEANUP LOGIC ---

        async function updatePlayerActivity() {
            if (!currentRoom || !myPlayerKey) return;
            
            const now = Date.now();
            if (now - lastActiveUpdate > ACTIVITY_THRESHOLD) {
                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, myPlayerKey);
                try {
                    await updateDoc(playerRef, {
                        lastActive: Date.now(),
                        online: true
                    });
                    lastActiveUpdate = now;
                } catch (e) {
                    // Player might be kicked/deleted
                }
            }
        }

        async function markPlayerOffline() {
            if (!currentRoom || !myPlayerKey) return;
            const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, myPlayerKey);
            try {
                await updateDoc(playerRef, {
                    online: false,
                    lastActive: Date.now()
                });
            } catch (e) {
                console.log("Could not mark player offline");
            }
        }

        function startPresenceUpdates() {
            if (presenceInterval) clearInterval(presenceInterval);
            presenceInterval = setInterval(updatePlayerActivity, 10000); // Heartbeat every 10s
            
            // Interaction listeners
            ['mousedown', 'mousemove', 'keydown', 'touchstart'].forEach(event => {
                document.addEventListener(event, updatePlayerActivity, { passive: true });
            });
        }

        async function cleanupInactivePlayers() {
            // Only host cleans up
            if (currentUser.uid !== currentHostUid) return;
            
            const playersCol = collection(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom);
            const playersSnap = await getDocs(playersCol);
            const now = Date.now();
            
            playersSnap.docs.forEach(async (playerDoc) => {
                const playerData = playerDoc.data();
                const lastActive = playerData.lastActive || 0;
                
                // Remove if offline AND inactive for > 30s
                if ((now - lastActive > INACTIVE_THRESHOLD) && !playerData.online) {
                    const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, playerData.id);
                    // Double check current status
                    const currentSnap = await getDoc(playerRef);
                    const currentData = currentSnap.exists() ? currentSnap.data() : null;
                    
                    if (currentData && !currentData.online) {
                         // Archive kicked/removed players logic can go here if needed, but for inactivity we just remove
                        await deleteDoc(playerRef);
                        
                        // If drawer was removed, rotate
                        if (playerData.id === currentDrawerId) {
                            await startNewRound(playerData.id);
                        }
                        
                        await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom), {
                            type: 'system',
                            text: `${playerData.name} removed due to inactivity.`,
                            time: Date.now()
                        });
                    }
                }
            });
        }

        // Window event listeners for offline status
        window.addEventListener('beforeunload', async (e) => { await markPlayerOffline(); });
        window.addEventListener('pagehide', async () => { await markPlayerOffline(); });
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden) await markPlayerOffline();
            else await updatePlayerActivity();
        });


        function listenToRoom(myKey) {
            // Room Listener
            onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom), (snap) => {
                if (!snap.exists()) {
                    alert('The host has ended the party!');
                    location.reload();
                    return;
                }

                const data = snap.data();
                currentHostUid = data.hostUid; // Store host UID
                currentDrawerId = data.drawerId; 
                correctGuessers = data.correctGuessers || [];
                roundDrawingStarted = data.drawingStarted || false;

                // HOST LOGIC
                if (currentHostUid === currentUser.uid) {
                    endRoomBtn.classList.remove('hidden');
                    // Start cleanup interval if not started
                    if (!window.cleanupInterval) {
                        window.cleanupInterval = setInterval(cleanupInactivePlayers, 15000); // Run cleanup every 15s
                    }

                    if (!hostTimerInterval) {
                        hostTimerInterval = setInterval(async () => {
                            const currentSnap = await getDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom));
                            if (!currentSnap.exists()) {
                                clearInterval(hostTimerInterval);
                                return;
                            }
                            const currentData = currentSnap.data();
                            
                            // TIMER PAUSE CHECK
                            if (!currentData.drawingStarted) return; 

                            let newTime = (currentData.timer || 0) - 1;
                            
                            if (newTime <= 0) {
                                startNewRound(currentData.drawerId);
                            } else {
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom), { timer: newTime });
                            }
                        }, 1000);
                    }
                }

                if (currentWord !== data.currentWord) {
                    currentWord = data.currentWord;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                const isMeDrawing = data.drawerId === myKey;
                currentRole = isMeDrawing ? 'drawer' : 'guesser';
                
                if (isMeDrawing) {
                    targetContainer.classList.remove('hidden');
                    targetWordText.textContent = currentWord;
                    drawerTools.classList.remove('hidden');
                } else {
                    targetContainer.classList.add('hidden');
                    drawerTools.classList.add('hidden');
                }
                timerDisplay.textContent = `${data.timer}s`;
            });

            // Player Listener
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom), (snap) => {
                const currentPlayers = snap.docs.map(d => d.data());
                
                // If I'm not in the list, I was kicked or removed
                const amIStillInGame = currentPlayers.some(p => p.id === myKey);
                if (myKey && !amIStillInGame) {
                    // Clear local storage so we don't auto-reconnect to a game we were kicked from
                    localStorage.removeItem('scribble_last_room');
                    alert("You have been kicked by the host.");
                    location.reload();
                    return;
                }

                playerListEl.innerHTML = '';
                snap.docs.forEach(doc => {
                    const p = doc.data();
                    const isHost = currentUser && currentHostUid === currentUser.uid;
                    const isThisPlayerHost = p.id.includes(currentHostUid); 
                    const isOnline = p.online !== false;
                    const isMe = p.id === myPlayerKey;

                    const item = document.createElement('div');
                    // Dim offline players
                    item.className = `flex justify-between items-center p-3 rounded-2xl transition-all ${isOnline ? 'bg-slate-50' : 'bg-gray-100 opacity-60'}`;
                    
                    item.innerHTML = `
                        <div class="flex items-center gap-2">
                            <div class="w-2 h-2 rounded-full ${isOnline ? 'bg-green-500' : 'bg-gray-400'}" title="${isOnline ? 'Online' : 'Offline'}"></div>
                            <span class="font-bold ${isOnline ? 'text-slate-700' : 'text-gray-500'}">${p.name} ${isMe ? '' : ''}</span>
                            ${p.id === currentDrawerId ? '<span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded">Drawing</span>' : ''}
                            ${isThisPlayerHost ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded">Host</span>' : ''}
                        </div>
                        <div class="flex items-center gap-3">
                            <span class="font-800 ${isOnline ? 'text-indigo-600' : 'text-gray-400'}">${p.score || 0}</span>
                            ${isHost && !isThisPlayerHost ? 
                                `<button class="kick-btn text-xs bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded-lg transition-colors" data-player-id="${p.id}">Kick</button>` : 
                                ''}
                        </div>
                    `;
                    playerListEl.appendChild(item);
                });

                document.querySelectorAll('.kick-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const playerId = e.target.getAttribute('data-player-id');
                        if (confirm('Are you sure you want to kick this player?')) {
                            await kickPlayer(playerId);
                        }
                    });
                });
            });

            // Stroke Listener
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'strokes_' + currentRoom), (snap) => {
                if (currentRole === 'guesser') {
                    snap.docChanges().forEach(change => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            if (data.type === 'clear') ctx.clearRect(0, 0, canvas.width, canvas.height);
                            else if (data.points) {
                                data.points.forEach(p => drawStroke(p.x1, p.y1, p.x2, p.y2, p.color, p.size));
                            }
                        } else if (change.type === "removed") {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    });
                }
            });

            // Chat Listener
            onSnapshot(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom), (snap) => {
                const messages = snap.docs.map(d => d.data()).sort((a,b) => a.time - b.time);
                chatMessagesEl.innerHTML = '';
                messages.forEach(msg => {
                    const isWinnerMsg = msg.type === 'correct';
                    const isSystem = msg.type === 'system' || isWinnerMsg;
                    const isMyWin = msg.winnerId === myKey;
                    const haveIGuessed = correctGuessers.includes(myKey);
                    
                    const canSeeDetails = !isWinnerMsg || (currentRole === 'drawer' || isMyWin || haveIGuessed);
                    
                    const el = document.createElement('div');
                    el.className = `message text-sm p-2 rounded-lg ${isSystem ? 'bg-indigo-50 text-indigo-600 font-bold' : 'bg-slate-100 text-slate-700'}`;
                    
                    if (isWinnerMsg) {
                        el.textContent = canSeeDetails ? `BINGO! ${msg.sender} guessed it!` : `Someone guessed the word!`;
                    } else {
                        el.textContent = isSystem ? msg.text : `${msg.sender}: ${msg.text}`;
                    }
                    chatMessagesEl.appendChild(el);
                });
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            });
        }

        async function kickPlayer(playerId) {
            try {
                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, playerId);
                const playerSnap = await getDoc(playerRef);
                
                if (playerSnap.exists()) {
                    const playerData = playerSnap.data();
                    
                    // Archive (Optional - simple deletion is often enough, but user requested logging)
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'kickedPlayers_' + currentRoom, playerId), {
                        ...playerData,
                        kickedAt: Date.now(),
                        kickedBy: currentUser.uid
                    });

                    // Delete active record
                    await deleteDoc(playerRef);
                    
                    // If kicked player was the drawer, start a new round
                    if (playerId === currentDrawerId) {
                        await startNewRound(playerId);
                    }
                    
                    // Remove player from correct guessers
                    const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
                    const roomSnap = await getDoc(roomRef);
                    if (roomSnap.exists()) {
                        const data = roomSnap.data();
                        if (data.correctGuessers && data.correctGuessers.includes(playerId)) {
                             const updatedGuessers = data.correctGuessers.filter(id => id !== playerId);
                            await updateDoc(roomRef, { correctGuessers: updatedGuessers });
                        }
                    }
                    
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom), { 
                        type: 'system', 
                        text: `${playerData.name} has been kicked from the game.`, 
                        time: Date.now() 
                    });
                }
            } catch (error) {
                console.error('Error kicking player:', error);
                alert('Failed to kick player. Please try again.');
            }
        }

        async function startNewRound(currentDrawerId) {
            // ROTATION LOGIC
            const playersCol = collection(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom);
            const playersSnap = await getDocs(playersCol);
            const players = playersSnap.docs.map(d => d.data().id).sort();

            // If no players left, end the game
            if (players.length === 0) {
                if (endRoomBtn) endRoomBtn.click();
                return;
            }

            let nextDrawerId = currentDrawerId;
            if (players.length > 0) {
                const currentIndex = players.indexOf(currentDrawerId);
                let nextIndex;
                
                if (currentIndex === -1) {
                    nextIndex = 0;
                } else {
                    nextIndex = (currentIndex + 1) % players.length;
                }
                nextDrawerId = players[nextIndex];
            }

            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
            await updateDoc(roomRef, {
                drawerId: nextDrawerId,
                currentWord: WORDS[Math.floor(Math.random() * WORDS.length)],
                timer: 60,
                correctGuessers: [],
                drawingStarted: false 
            });

            const batch = writeBatch(db);
            const strokes = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'strokes_' + currentRoom));
            strokes.forEach(d => batch.delete(d.ref));
            const msgs = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom));
            msgs.forEach(d => batch.delete(d.ref));
            const msgRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom));
            batch.set(msgRef, { type: 'system', text: "Time's up! New round started.", time: Date.now() });
            await batch.commit();
        }

        endRoomBtn.onclick = async () => {
            if (!confirm('Are you sure you want to end this party? This will kick all players.')) return;
            const batch = writeBatch(db);
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
            batch.delete(roomRef);
            const collectionsToDelete = ['players_', 'strokes_', 'messages_'];
            for (const prefix of collectionsToDelete) {
                const q = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', prefix + currentRoom));
                q.forEach((doc) => batch.delete(doc.ref));
            }
            await batch.commit();
        };

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        }

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            return [x / canvas.width, y / canvas.height];
        }

        async function flushStrokeBuffer() {
            if (strokeBuffer.length === 0 || isFlushing) return; 
            
            isFlushing = true;
            const pointsToPush = [...strokeBuffer];
            strokeBuffer = []; 

            try {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'strokes_' + currentRoom), { 
                    points: pointsToPush, 
                    time: Date.now() 
                });
            } catch (e) {
                console.error("Error syncing strokes", e);
            } finally {
                isFlushing = false;
            }
        }

        canvas.onmousedown = (e) => {
            if (currentRole !== 'drawer') return;
            isDrawing = true;
            
            // TIMER START TRIGGER
            if (!roundDrawingStarted) {
                roundDrawingStarted = true;
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
                updateDoc(roomRef, { drawingStarted: true }).catch(console.error);
            }

            [lastX, lastY] = getCoords(e);
            if (!bufferTimer) bufferTimer = setInterval(flushStrokeBuffer, 50);
        };

        const MIN_DISTANCE = 0.005;

        canvas.onmousemove = (e) => {
            if (!isDrawing || currentRole !== 'drawer') return;
            const [x, y] = getCoords(e);
            
            const dist = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
            if (dist < MIN_DISTANCE) return; 

            drawStroke(lastX, lastY, x, y, brushColor, brushSize);
            strokeBuffer.push({ x1: lastX, y1: lastY, x2: x, y2: y, color: brushColor, size: brushSize });
            [lastX, lastY] = [x, y];
        };

        window.onmouseup = () => {
            isDrawing = false;
            clearInterval(bufferTimer);
            bufferTimer = null;
            isFlushing = false; 
            flushStrokeBuffer();
        };

        function drawStroke(x1, y1, x2, y2, color, size) {
            ctx.beginPath();
            ctx.strokeStyle = color; ctx.lineWidth = size;
            ctx.moveTo(x1 * canvas.width, y1 * canvas.height);
            ctx.lineTo(x2 * canvas.width, y2 * canvas.height);
            ctx.stroke();
        }

        window.setColor = (c) => brushColor = c;
        document.getElementById('clear-btn').onclick = async () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'strokes_' + currentRoom), { type: 'clear', time: Date.now() });
        };

        // --- NEW BUTTON HANDLERS ---
        document.getElementById('change-word-btn').onclick = async () => {
            if (currentRole !== 'drawer') return;
            // Pick a new random word
            const newWord = WORDS[Math.floor(Math.random() * WORDS.length)];
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
            // Update the room; the existing onSnapshot listener will catch this change
            // and automatically clear the canvas for everyone.
            await updateDoc(roomRef, { currentWord: newWord });
        };

        document.getElementById('skip-round-btn').onclick = async () => {
            if (currentRole !== 'drawer') return;
            if (confirm("Are you sure you want to end this round early?")) {
                // Pass current drawer ID to rotation logic to trigger the next person
                await startNewRound(myPlayerKey);
            }
        };

        // ---------------------------

        chatForm.onsubmit = async (e) => {
            e.preventDefault();
            const text = chatInput.value.trim();
            if (!text || !myPlayerKey) return;
            chatInput.value = '';
            const playerName = document.getElementById('player-name').value;
            const isCorrect = text.toUpperCase() === currentWord.toUpperCase();

            if (isCorrect && currentRole === 'guesser' && !correctGuessers.includes(myPlayerKey)) {
                const rank = correctGuessers.length; 
                let points = 0;
                if (rank === 0) points = 30;
                else if (rank === 1) points = 20;
                else if (rank === 2) points = 10;
                
                const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'rooms', currentRoom);
                await updateDoc(roomRef, {
                    correctGuessers: arrayUnion(myPlayerKey)
                });

                // Award points to the guesser
                if (points > 0) {
                    const pRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, myPlayerKey);
                    await updateDoc(pRef, { score: increment(points) });
                }

                // Award 5 points to the drawer for a correct guess
                if (currentDrawerId) {
                    const drawerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players_' + currentRoom, currentDrawerId);
                    await updateDoc(drawerRef, { score: increment(5) });
                }

                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom), {
                    type: 'correct', winnerId: myPlayerKey, sender: playerName, time: Date.now()
                });
            } else {
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'messages_' + currentRoom), { sender: playerName, text, time: Date.now() });
            }
        };

        window.onresize = resizeCanvas;
    </script>
</body>
</html>